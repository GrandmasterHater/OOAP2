   Примеры используют рефлексию для проверки совместимости типа. Кажды проверяет можно ли переменной 
типа targety присвоить переменную с типом source. Моё решение несколько отличается от эталонов - использую
рантайм безопасное приведение типа через ключевое слово `as`. Т.к. в C# невозможно реализовать настоящий None
замыкающий иерархию, то решил использовать null подразумевая его как тип показывающий отсутствующий/пустой
объект. Сначала как и в примере Java думал сделать статический метод присваивания, однако рассудил, что
операция присвоения это работа с инстансами объектов, а значит нужно сделать это операцией (командой)
для базового типа General. Для проверки того что передаваймый тип принадлежит системе типов начинающейся 
от General использую дженерик и ограничения, что метод можно вызывать только для наследников General. 
Также решил совместитбь команду и получение результата выполнения команды (статус), поэтому метод возвращает
статус типа bool (успешно/не успешно), а само присвоение реализовано через `out` параметр. Понимаю, что это 
откланяется от приципов формирования АТД поскольку команды ничего не должны возвращать, но на момент 
реализации такое показалось рациональным. 
