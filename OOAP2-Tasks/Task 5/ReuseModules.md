Испорльзую С#. Основными единицами модульности являются сборки (Assembly) и пространства имён (namespace). Если рассматривать класс как наименьшее представление модуля, то тогда и классы.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики): 
   Да, но с ограничениями. В С# можно поддерживать параметризацию на уровне классов, но вот неймспейсы и сборки (соответсвенно и .dll) такого не могут. Например в модуле коллекций `System.Collections.Generic` классы используют 
   парамтеризацию другими типами, наприме рпри создании списка.

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;:
   Есть. В рамках пространства имён или сборки есть взаимодействие.

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля:
   Есть. Модули можно связывать через ссылки (Add Reference или NuGet packages).

4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра:
   Нет. Разработчику самому в ручную нужно расширять модули переопределяя интерфейсы и абстрактные классы.
   
5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями:
   В целом вроде бы да. Возможно не очень хорошо пока понимаю этот пункт, но если подразумевается возможность в некий третий модуль импортировать и комбинировать поведение других модулей, то да.
